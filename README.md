## Running the app
### With Docker
Give execution permission for './scripts/init-environment.sh' and './scripts/rs-init.sh'

With:

```bash
$ sudo chmod 777 -R ./scripts
```

Clone the file `.env.example` and rename it to `.env`.

Then run:

```bash
$ yarn init:env
$ #or
$ npm run init:env
```
This script will run the API instance and the MongoDB instances that must run in cluster mode (this is a Prisma ORM requirement).
If you don't want to run the cluster on docker-compose, you can create an [Atlas](https://www.mongodb.com/atlas/database) cluster for free and remove MongoDB from `docker-compose.yml` file.

### Without Docker
Clone the file `.env.example` and rename it to `.env`.

Fill the env variables

***Remember that Prisma ORM needs the MongoDB server to be running in cluster mode for data integrity reasons.***

```bash
$ yarn start:dev
$ #or
$ npm run start:dev
```

### Running the seeds
After run the app we need to populate the database with few pre-registered data.

Populate database running the following command:

```bash
$ yarn seed:dev
$ #or
$ npm run seed:dev
```

## Test
Run unit tests with following command:
```bash
$ npm run test
$ #or
$ yarn test
```

## Pre Registered Data

The pre-registered data are some user roles along with their respective permissions.
There are two types of user roles: `ADMIN` and `CUSTOMER`.

And some permissions are for keeping books and rents.

There is a default admin user and his access credentials are:

- email: `admin@email.com`
- password: `123@abcd`

## Patterns that must be used

### Prisma Models and Settings
You can create each Prisma model separately in the `/src/infra/database/prisma/models` folder. Also, you can edit Prisma settings in:
`/src/infra/database/prisma/config.prisma`.

***Do not change the schema.prisma file, because this file is automatically generated when running the command: `yarn sync` or `npm run sync`***

### ModelDataView
This project uses a pattern to split the format of the database, presentation (and other layers that the system may have).
In this project I'm calling it ModelDataView, because as it is an API in the MVC pattern, our presentation layer would be a data set.
This pattern is also called Mapper or DTO.

When creating an endpoint that returns a certain entity from the database, a class must be created with the suffix "DataView", example: "UserDataView" or "BookDataView".
Then the fields that will be displayed in the API response must be declared and added to the constructor.

then create static methods that convert the entity from some layer to the presentation layer.

example: "fromDatabaseModel" if converting the entity from database layer.

### Seeds
To create the seeds in the project you can use the classes: `Seeder` and `SeederRunner`.

The `Seeder` class is an abstract class that has a seed method and a "get" method called "data".
When creating a seeder, you must extend this class.
The "seed" method is responsible for containing the insertion logic, while the "get data" method must return the data that will be inserted.

This format is used to be able to reuse the insertion logic of a seeder in other later seeders.
Each seeder is executed only once and a record is created in the database in a collection called: `__executed_seeds`.

After creating a Seeder class, just go to the seeder entry point and create an instance of the `SeederRunner` class, passing the Prisma connection as a parameter.

After that you can run the "run" method and pass your seeders as a parameter.

The Seeder class uses dependency inversion to depend on just one interface of a Prisma connection and the SeederRunner class is responsible for injecting the connection into each instance of the Seeder class.

### Input, Validation and Serialization
In most requests we need to send some data to the API, either as a parameter, query or body.
On most of these occasions we need to validate some of this information and serialize it before it gets into the methods that will execute the business rules.

For this we use a set of libraries called: class-validator and class-transformer. These two libraries are responsible for validating and/or serializing data.

Nestjs already has an integration with this library, so you can see how they work in the [official documentation](https://docs.nestjs.com/techniques/validation).

The standard we use in data entry is called DTO (Data Transfer Object). For each request that needs data from the client, a DTO class must be created inside the folder: "dto" of each system module. The name of the dto must be the name of the controller method that will be responsible for processing the request followed by the suffix: "dto". Examples:

File name: create-user.dto.ts.
Class name: CreateUserDto.

For security and performance reasons, always use the "Exclude" and "Expose" decorators of the class-transformer to fetch only the data that you will actually use in processing the request.

## Useful commands
You can use some commands from the "package.json" file to perform certain tasks.

- `start:dev`: starts the project in development mode
- `seed`: Run Prisma seeds.
- `sync`: Compiles the Prisma models and executes the "generate" command to generate the types in `node_module/.prisma`.


If you are using `docker-compose` to upload the application, sometimes it is necessary to access the container to execute a command.
Below I have listed some useful commands to use when using `docker-compose`

init:env: Starts the project in development mode using docker-compose. This command will run the script in: `/scripts/init-enviroment.sh`. This script build the instance of the application, the instances of the databases and activates the "Cluster" mode of MongoDB.

- `seed:dev`: runs Prisma seeds inside the container;
- `sync:dev`: Run the `sync` command inside docker;
